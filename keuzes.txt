Mogelijke keuzes:
- SyncVal in leaves of niet
- 

Mogelijke simplificaties:
- if-statements (tijdelijk, niet in eindresultaat)
- Geen pattern-matching op NonSyncVals
- Enkel eq als relop (tijdelijk)

Gemaakte keuzes:
- Disabled:
	+ Type constructors: 
		* Enum
		* Union
		* Record
		* Tuple
		* List
		* Sum
	+ Patterns:
		* Anything to do with the turned of types
		* Pattern_bvec_exhaustive
	+ Pattern_match_relval_reverse returned een option (RelVal sigma), dit is logisch, want niet alle environments zijn mogelijk voor pattern matching (pattern_match_relval is niet surjectief):
		Een andere gesophisticeerdere oplossing zou een relatie zijn, maar dat kunnen we later nog doen (option is eigenlijk al een stap richting een relatie)
	+ BinOp: didn't turn off, everything except eq, because it seemed more work than it simplified
	+ Use if instead of pattern match: didn't do this for now, because of problems encountered in Assertions.v, it didn't seem worth it.	
	
- Voorstelling RelVal: Uniform in het type
	Ondersteuning voor projectie en Val omzetten naar RelVal (dus gebruik hier niet SyncVal voor).
	We behouden RV om eventueel te gebruiken voor RV Prop in eval_relop_propRel.
	Encountered problems: 
	
- Pattern_match_relval gebruikt projLeft voor Boolean (hierbij maakt het gebruik van het feit dat SyncVal geÃ«ist wordt)
	Dit zal door bepaalde lemma gecheckt worden dat de uitkomst dezelfde is als effectief pattern matchen.
	
- Eval_relop_relval en eval_relop_relprop geven gewoon een gelifte versie terug, het samenvoegen gebeurt later (zo kan het resultaat van een vergelijking een NonSyncVal zijn die dan een falende pattern_match impliceert)

- Added a term_relval to terms: originally prompted by problems to make inst_lift_term in instantation work.



Inadequacies:
- Terms are not rings anymore (NonSyncVal 1 1 - NonSyncVal 1 1 = NonSyncVal 0 0 != SyncVal 0).

