(******************************************************************************)
(* Copyright (c) 2020 Dominique Devriese, Sander Huyghebaert, Steven Keuchel  *)
(* All rights reserved.                                                       *)
(*                                                                            *)
(* Redistribution and use in source and binary forms, with or without         *)
(* modification, are permitted provided that the following conditions are     *)
(* met:                                                                       *)
(*                                                                            *)
(* 1. Redistributions of source code must retain the above copyright notice,  *)
(*    this list of conditions and the following disclaimer.                   *)
(*                                                                            *)
(* 2. Redistributions in binary form must reproduce the above copyright       *)
(*    notice, this list of conditions and the following disclaimer in the     *)
(*    documentation and/or other materials provided with the distribution.    *)
(*                                                                            *)
(* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        *)
(* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *)
(* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR *)
(* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR          *)
(* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *)
(* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *)
(* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *)
(* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *)
(* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *)
(* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *)
(* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *)
(******************************************************************************)

From Coq Require Import
     Strings.String
     ZArith.BinInt.
From Katamaran Require Import
     Signature
     Sep.Hoare
     Specification
     Prelude
     Program
     MicroSail.ShallowExecutor.

Set Implicit Arguments.

Import ctx.notations.
Import env.notations.

Module Type Soundness
  (Import B : Base)
  (Import SIG : Signature B)
  (Import PROG : Program B)
  (Import SPEC : Specification B SIG PROG)
  (Import EXEC : ShallowExecOn B SIG PROG SPEC)
  (Import HOAR : ProgramLogicOn B SIG PROG SPEC).

  Import CStoreSpec.
  Import ProgramLogic.

  Section Soundness.

    Import iris.proofmode.tactics.

    Context {L} {biA : BiAffine L} {PI : PredicateDef L}.

    (* liftP converts the "proof theoretic" predicates (CStore Œì -> L), with L
       being a type of separation logic propositions, to the "model theoretic"
       heap predicates (CStore Œì -> SCHeap -> Prop) that are used as the type of
       postconditions in the shallow executor. *)
    Definition liftP {Œì} (POST : CStore Œì -> L) : CStore Œì -> SCHeap -> Prop :=
      fun Œ¥ h => interpret_scheap h ‚ä¢ POST Œ¥.

    Lemma call_contract_sound {Œî œÑ} (c : SepContract Œî œÑ) (args : CStore Œî)
      (Œ¶ : RelVal œÑ ‚Üí SCHeap ‚Üí Prop) (h1 : SCHeap) :
      CHeapSpec.call_contract c args Œ¶ h1 ‚Üí
      CTriple (interpret_scheap h1) c args
        (fun v => ‚àÉ h' : SCHeap, interpret_scheap h' ‚àß ‚åúŒ¶ v h'‚åù)%I.
    Proof.
      destruct c as [Œ£e Œ¥e req result ens]. cbn.
      cbv [CHeapSpec.call_contract CHeapSpec.bind CHeapSpec.lift_purespec
           CHeapSpec.demonic CPureSpec.demonic].
      rewrite CPureSpec.wp_angelic_ctx.
      intros [Œπ Hwp]; revert Hwp.
      rewrite CPureSpec.wp_assert_eq_nenv.
      intros [Hfmls ->%CHeapSpec.consume_sound].
      apply bi.exist_intro' with Œπ.
      apply bi.and_intro; auto.
      apply bi.sep_mono'; auto.
      apply bi.exist_elim. intros h'.
      apply bi.pure_elim_r.
      intros Hwp. apply bi.forall_intro; intro v.
      specialize (Hwp v). now apply CHeapSpec.produce_sound in Hwp.
    Qed.

    Lemma call_lemma_sound [Œî] (l : Lemma Œî) (Œ¥ : CStore Œî)
      (Œ¶ : () ‚Üí SCHeap ‚Üí Prop) (h : SCHeap)   :
      CHeapSpec.call_lemma l Œ¥ Œ¶ h ‚Üí
      LTriple Œ¥ (interpret_scheap h) (‚àÉ h', interpret_scheap h' ‚àß ‚åúŒ¶ tt h'‚åù) l.
    Proof.
      destruct l as [Œ£e Œ¥e req ens].
      unfold CHeapSpec.call_lemma.
      unfold CHeapSpec.bind, CHeapSpec.lift_purespec.
      rewrite CPureSpec.wp_angelic_ctx.
      intros [Œπ Hwp]; revert Hwp.
      rewrite CPureSpec.wp_assert_eq_nenv.
      intros [Hfmls Hwp%CHeapSpec.consume_sound].
      constructor.
      apply bi.exist_intro' with Œπ.
      apply bi.and_intro; auto.
      rewrite Hwp. clear Hwp.
      apply bi.sep_mono'; auto.
      apply bi.exist_elim. intros h'.
      apply bi.pure_elim_r.
      apply CHeapSpec.produce_sound.
    Qed.

    Definition SoundExecCall (exec_call : ExecCall) : Prop :=
      forall Œì œÑ Œî (f : ùë≠ Œî œÑ) (es : NamedEnv (Exp Œì) Œî)
        (Œ¶ : RelVal œÑ ‚Üí SCHeap ‚Üí Prop)
        (Œ¥1 : CStore Œì) (h1 : SCHeap),
        exec_call _ _ f (evals es Œ¥1) Œ¶ h1 ‚Üí
        ‚¶É interpret_scheap h1 ‚¶Ñ
          stm_call f es; Œ¥1
        ‚¶É fun v Œ¥' =>
            ‚àÉ h' : SCHeap, interpret_scheap h' ‚àß ‚åúŒ¶ v h' ‚àß Œ¥' = Œ¥1‚åù ‚¶Ñ.

    Definition SoundExecCallForeign (exec_call_foreign : ExecCallForeign) : Prop :=
      forall Œì œÑ Œî (f : ùë≠ùëø Œî œÑ) (es : NamedEnv (Exp Œì) Œî)
        (Œ¶ : RelVal œÑ ‚Üí SCHeap ‚Üí Prop) (Œ¥1 : CStore Œì) (h1 : SCHeap),
      exec_call_foreign _ _ f (evals es Œ¥1) Œ¶ h1 ‚Üí
      ‚¶É interpret_scheap h1 ‚¶Ñ
        stm_foreign f es; Œ¥1
      ‚¶É fun v Œ¥' =>
          ‚àÉ h' : SCHeap, interpret_scheap h' ‚àß ‚åúŒ¶ v h' ‚àß Œ¥' = Œ¥1‚åù ‚¶Ñ.

    Definition SoundExecLemma (exec_lemma : ExecLemma) : Prop :=
      forall Œì Œî (l : ùë≥ Œî) (es : NamedEnv (Exp Œì) Œî)
        (Œ¶ : unit ‚Üí SCHeap ‚Üí Prop) (Œ¥1 : CStore Œì) (h1 : SCHeap),
      exec_lemma _ l (evals es Œ¥1) Œ¶ h1 ‚Üí
      LTriple (evals es Œ¥1) (interpret_scheap h1)
        (‚àÉ h' : SCHeap, interpret_scheap h' ‚àß ‚åúŒ¶ tt h'‚åù)
        (LEnv l).

    Definition SoundExec (exec : Exec) :=
      forall
        Œì œÉ (s : Stm Œì œÉ) (Œ¶ : RelVal œÉ ‚Üí CStore Œì ‚Üí SCHeap ‚Üí Prop)
        (Œ¥1 : CStore Œì) (h1 : SCHeap),
        exec _ _ s Œ¶ Œ¥1 h1 ->
        ‚¶É interpret_scheap h1 ‚¶Ñ
          s ; Œ¥1
        ‚¶É fun v Œ¥' =>
            ‚àÉ h' : SCHeap, interpret_scheap h' ‚àß ‚åúŒ¶ v Œ¥' h'‚åù
        ‚¶Ñ.

    Section ExecAux.

      Variable exec_call_foreign : ExecCallForeign.
      Variable exec_lemma : ExecLemma.
      Variable exec_call : ExecCall.

      Variable mexec_call_foreign : MonotonicExecCallForeign exec_call_foreign.
      Variable mexec_lemma : MonotonicExecLemma exec_lemma.
      Variable mexec_call : MonotonicExecCall exec_call.

      Variable sound_exec_call_foreign : SoundExecCallForeign exec_call_foreign.
      Variable sound_exec_lemma : SoundExecLemma exec_lemma.
      Variable sound_exec_call : SoundExecCall exec_call.

      Lemma exec_aux_sound :
        SoundExec (exec_aux exec_call_foreign exec_lemma exec_call).
      Proof.
        unfold SoundExec. intros ? ? s.
        induction s; intros ? ? ?; cbn;
          cbv [pure pushspops pushpop eval_exp get_local put_local bind];
          cbn; intros HYP.

        - (* stm_val *)
          apply rule_stm_val.
          apply bi.exist_intro' with h1.
          apply bi.and_intro.
          reflexivity.
          apply bi.pure_intro.
          auto.

        (* - (* stm_relval *) *)
        (*   apply rule_stm_relval. *)
        (*   apply bi.exist_intro' with h1. *)
        (*   apply bi.and_intro. *)
        (*   reflexivity. *)
        (*   apply bi.pure_intro. *)
        (*   auto.   *)

        - (* stm_exp *)
          apply rule_stm_exp.
          apply bi.exist_intro' with h1.
          apply bi.and_intro.
          reflexivity.
          apply bi.pure_intro.
          auto.

        - (* stm_let *)
          eapply rule_stm_let.
          apply IHs1, HYP. clear IHs1 HYP.
          intros v1 Œ¥2.
          apply rule_exist. intros h.
          apply rule_pull. intros HYP.
          now apply IHs2.

        - (* stm_block *)
          now apply rule_stm_block, IHs.

        - (* stm_assign *)
          now apply rule_stm_assign, IHs.

        - (* stm_call *)
          eapply sound_exec_call in HYP.
          apply (rule_consequence_right _ HYP).
          intros.
          apply bi.exist_mono'. intros h.
          apply bi.and_mono'; auto.
          apply bi.pure_mono; intros []; now subst.

        - (* stm_call_frame *)
          now apply rule_stm_call_frame, IHs.

        - (* stm_foreign *)
          eapply sound_exec_call_foreign in HYP.
          apply (rule_consequence_right _ HYP).
          intros.
          apply bi.exist_mono'. intros h.
          apply bi.and_mono'; auto.
          apply bi.pure_mono; intros []; now subst.

        - (* stm_lemmak *)
          eapply rule_stm_lemmak.
          apply (sound_exec_lemma _ _ HYP). clear HYP.
          apply rule_exist. intros h.
          apply rule_pull. intros HYP.
          now apply IHs.

        - (* stm_seq *)
          eapply rule_stm_seq.
          apply IHs1, HYP. clear IHs1 HYP.
          intros v1 Œ¥2.
          apply rule_exist. intros h.
          apply rule_pull. intros HYP.
          now apply IHs2.

        - (* stm_assert *)
          apply rule_stm_assert; intro Heval.
          apply IHs, HYP.
          destruct (eval e1 Œ¥1).
          + now subst.
          + contradiction.

        - (* stm_fail *)
          eapply rule_consequence_left.
          apply rule_stm_fail.
          apply bi.True_intro.

        - (* stm_match_pattern *)
          eapply rule_stm_pattern_match.
          apply IHs, HYP. clear IHs HYP.
          intros pc Œ¥pc Œ¥Œì'. cbn.
          apply rule_exist. intros h.
          apply rule_pull. intros HYP.
          apply wp_demonic_pattern_match in HYP.
          rewrite pattern_match_relval_inverse_right in HYP.
          destruct (ty.unliftNamedEnv Œ¥pc).
          + inversion HYP. now apply H.
          + inversion HYP.

        - (* stm_read_register *)
          destruct HYP as [v HYP].
          eapply rule_consequence_left.
          apply (rule_stm_read_register_backwards (v := v)).
          apply CPureSpec.wp_consume_chunk in HYP.
          rewrite HYP. clear HYP. cbn.
          apply bi.sep_mono'. easy.
          apply bi.exist_elim. intros h2.
          apply bi.pure_elim_r.
          now intros ->%CPureSpec.wp_produce_chunk.

        - (* stm_write_register *)
          destruct HYP as [v HYP].
          eapply rule_consequence_left.
          apply (rule_stm_write_register_backwards (v := v)).
          apply CPureSpec.wp_consume_chunk in HYP.
          rewrite HYP. clear HYP. cbn.
          apply bi.sep_mono'. easy.
          apply bi.exist_elim. intros h2.
          apply bi.pure_elim_r.
          now intros ->%CPureSpec.wp_produce_chunk.

        - (* stm_bind *)
          unfold error in HYP.
          contradiction.

        - (* stm_debug *)
          constructor. auto.
      Qed.

    End ExecAux.

    Section WithExec.

      Context (exec : Exec) (mexec : MonotonicExec exec) (sound_exec : SoundExec exec).

      Lemma exec_contract_sound [Œî œÑ] (c : SepContract Œî œÑ) (body : Stm Œî œÑ) Œ¶ h :
        exec_contract exec c body Œ¶ h ‚Üí
        ‚àÄ Œπ : Valuation (sep_contract_logic_variables c),
        ‚¶É interpret_scheap h ‚àó
          asn.interpret (sep_contract_precondition c) Œπ ‚¶Ñ
          body ; inst (sep_contract_localstore c) Œπ
        ‚¶É fun v _ =>
            asn.interpret
              (sep_contract_postcondition c)
              Œπ.[sep_contract_result c‚à∑œÑ ‚Ü¶ v] ‚àó
            ‚àÉ h', ‚åú Œ¶ tt h' ‚åù ‚¶Ñ.
      Proof.
        destruct c as [Œ£ Œ¥Œ£ req result ens]; cbn.
        cbv [CHeapSpec.bind CHeapSpec.demonic_ctx
               CHeapSpec.lift_purespec evalStoreSpec].
        intros HYP Œπ.
        rewrite CPureSpec.wp_demonic_ctx in HYP.
        specialize (HYP Œπ). remember (inst Œ¥Œ£ Œπ) as Œ¥.
        apply CHeapSpec.produce_sound, bi.wand_elim_l' in HYP.
        refine (rule_consequence_left _ _ HYP). clear HYP.
        apply rule_exist. intros h'.
        apply rule_pull. intros HYP.
        eapply sound_exec in HYP.
        apply (rule_consequence_right _ HYP).
        intros v _.
        apply bi.exist_elim. intros h2.
        apply bi.pure_elim_r.
        intros ->%CHeapSpec.consume_sound.
        apply bi.sep_mono'; auto.
        apply bi.exist_elim. intros h3.
        apply bi.pure_elim_r. auto.
      Qed.

    End WithExec.

    Lemma sound_cexec_call_foreign : SoundExecCallForeign cexec_call_foreign.
    Proof.
      unfold SoundExecCallForeign, cexec_call_foreign.
      intros * HYP%call_contract_sound. constructor.
      destruct (CEnvEx f) as [Œ£ Œ¥Œ£ req result ens]; cbn in *.
      rewrite HYP. clear HYP.
      apply bi.exist_mono'. intros Œπ.
      apply bi.and_mono'; auto.
      apply bi.sep_mono'; auto.
      apply bi.forall_mono'; intros v.
      apply bi.wand_mono'. easy.
      apply bi.exist_mono'. intros h'.
      apply bi.and_mono'; auto.
    Qed.

    Lemma sound_cexec_lemma : SoundExecLemma cexec_lemma.
    Proof.
      unfold SoundExecLemma, cexec_lemma. intros *.
      now apply call_lemma_sound.
    Qed.

    Lemma sound_cexec_call (fuel : nat) : SoundExecCall (cexec_call fuel).
    Proof.
      induction fuel; unfold SoundExecCall, evalStoreSpec; cbn; intros.
      - destruct (CEnv f) as [c|] eqn:?.
        + apply call_contract_sound in H.
          apply rule_stm_call with c; auto. clear Heqo.
          destruct c as [Œ£ Œ¥Œ£ req result ens]; cbn in *.
          rewrite H. clear H.
          apply bi.exist_mono'. intros Œπ.
          apply bi.and_mono'; auto.
          apply bi.sep_mono'; auto.
          apply bi.forall_mono'; intros v.
          apply bi.wand_mono'. easy.
          apply bi.exist_mono'. intros h'.
          apply bi.and_mono'; auto.
        + contradiction H.
      - destruct (CEnv f) as [c|] eqn:?.
        + apply call_contract_sound in H.
          apply rule_stm_call with c; auto. clear Heqo.
          destruct c as [Œ£ Œ¥Œ£ req result ens]; cbn in *.
          rewrite H. clear H.
          apply bi.exist_mono'. intros Œπ.
          apply bi.and_mono'; auto.
          apply bi.sep_mono'; auto.
          apply bi.forall_mono'; intros v.
          apply bi.wand_mono'. easy.
          apply bi.exist_mono'. intros h'.
          apply bi.and_mono'; auto.
        + apply rule_stm_call_inline.
          eapply exec_aux_sound in H.
          * apply (rule_consequence_right _ H).
            intros ? _.
            apply bi.exist_mono'. intros h.
            apply bi.and_mono'; auto.
          * apply sound_cexec_call_foreign.
          * apply sound_cexec_lemma.
          * auto.
    Qed.

    Lemma sound_cexec (fuel : nat) : SoundExec (cexec fuel).
    Proof.
      apply exec_aux_sound.
      - apply sound_cexec_call_foreign.
      - apply sound_cexec_lemma.
      - apply sound_cexec_call.
    Qed.

    Lemma vcgen_sound fuel {Œî œÑ} (c : SepContract Œî œÑ) (body : Stm Œî œÑ) :
      vcgen fuel c body ->
      ProgramLogic.ValidContract c body.
    Proof.
      cbv [vcgen CHeapSpec.run ProgramLogic.ValidContract]. intros HYP Œπ.
      eapply exec_contract_sound in HYP; auto using sound_cexec. cbn in HYP.
      rewrite bi.emp_sep in HYP.
      apply (rule_consequence_right _ HYP). clear HYP.
      intros ? _.
      apply bi.sep_elim_l; auto with typeclass_instances.
    Qed.

    Lemma shallow_vcgen_soundness {Œî œÑ} (c : SepContract Œî œÑ) (body : Stm Œî œÑ) :
      Shallow.ValidContract c body ->
      ProgramLogic.ValidContract c body.
    Proof. apply vcgen_sound. Qed.

    Lemma shallow_vcgen_fuel_soundness {Œî œÑ} (fuel : nat) (c : SepContract Œî œÑ) (body : Stm Œî œÑ) :
      Shallow.ValidContractWithFuel fuel c body ->
      ProgramLogic.ValidContract c body.
    Proof. apply vcgen_sound. Qed.

    (* Print Assumptions shallow_vcgen_soundnes. *)

  End Soundness.

End Soundness.

Module MakeShallowSoundness
  (Import B : Base)
  (Import SIG : Signature B)
  (Import PROG : Program B)
  (Import SPEC : Specification B SIG PROG)
  (Import EXEC : ShallowExecOn B SIG PROG SPEC)
  (Import HOAR : ProgramLogicOn B SIG PROG SPEC).

  Include Soundness B SIG PROG SPEC EXEC HOAR.

End MakeShallowSoundness.
