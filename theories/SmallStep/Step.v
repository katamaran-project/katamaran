(******************************************************************************)
(* Copyright (c) 2019 Steven Keuchel, Georgy Lukyanov                         *)
(* All rights reserved.                                                       *)
(*                                                                            *)
(* Redistribution and use in source and binary forms, with or without         *)
(* modification, are permitted provided that the following conditions are     *)
(* met:                                                                       *)
(*                                                                            *)
(* 1. Redistributions of source code must retain the above copyright notice,  *)
(*    this list of conditions and the following disclaimer.                   *)
(*                                                                            *)
(* 2. Redistributions in binary form must reproduce the above copyright       *)
(*    notice, this list of conditions and the following disclaimer in the     *)
(*    documentation and/or other materials provided with the distribution.    *)
(*                                                                            *)
(* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        *)
(* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *)
(* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR *)
(* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR          *)
(* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *)
(* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *)
(* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *)
(* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *)
(* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *)
(* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *)
(* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *)
(******************************************************************************)

From Coq Require Import
     Program.Tactics
     Strings.String
     ZArith.BinInt.
From Equations Require Import
     Equations.
From Katamaran Require Import
     Notations
     Program
     Tactics.

Set Implicit Arguments.

Module Type SmallStepOn (Import B : Base) (Import P : Program B).

  Import ctx.notations.
  Import env.notations.

  Inductive Step {Œì : PCtx} {œÑ : Ty} (Œ≥ : RegStore) (Œº : Memory) (Œ¥ : CStore Œì) :
    forall (Œ≥2 : RegStore) (Œº2 : Memory) (Œ¥2 : CStore Œì) (s1 s2 : Stm Œì œÑ), Prop :=

  | step_stm_exp
      (e : Exp Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , (stm_exp e) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_val œÑ (eval e Œ¥) ‚ü©

  | step_stm_let_value
      (x : PVar) (œÉ : Ty) (v : Val œÉ) (k : Stm (Œì ‚ñª x‚à∑œÉ) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_let x œÉ (stm_val œÉ v) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_block (env.snoc env.nil (x‚à∑œÉ) v) k ‚ü©
  | step_stm_let_fail
      (x : PVar) (œÉ : Ty) (s : string) (k : Stm (Œì ‚ñª x‚à∑œÉ) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥, stm_let x œÉ (stm_fail œÉ s) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©
  | step_stm_let_step
      (x : PVar) (œÉ : Ty) (s s' : Stm Œì œÉ) (k : Stm (Œì ‚ñª x‚à∑œÉ) œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) (Œ¥' : CStore Œì) :
      ‚ü® Œ≥ , Œº , Œ¥ , s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , s' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_let x œÉ s k ‚ü© ---> ‚ü® Œ≥', Œº' , Œ¥' , stm_let x œÉ s' k ‚ü©
  | step_stm_block_value
      (Œî : PCtx) (Œ¥Œî : CStore Œî) (v : Val œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_block Œ¥Œî (stm_val œÑ v) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_val œÑ v ‚ü©
  | step_stm_block_fail
      (Œî : PCtx) (Œ¥Œî : CStore Œî) (s : string) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_block Œ¥Œî (stm_fail œÑ s) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©
  | step_stm_block_step
      (Œî : PCtx) (Œ¥Œî Œ¥Œî' : CStore Œî) (k k' : Stm (Œì ‚ñª‚ñª Œî) œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) (Œ¥' : CStore Œì) :
      ‚ü® Œ≥ , Œº , Œ¥ ‚ñ∫‚ñ∫ Œ¥Œî , k ‚ü© ---> ‚ü® Œ≥', Œº' , Œ¥' ‚ñ∫‚ñ∫ Œ¥Œî' , k' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_block Œ¥Œî k ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , stm_block Œ¥Œî' k' ‚ü©

  | step_stm_seq_step
      (œÉ : Ty) (s s' : Stm Œì œÉ) (k : Stm Œì œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) (Œ¥' : CStore Œì) :
      ‚ü® Œ≥ , Œº , Œ¥ , s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , s' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_seq s k ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , stm_seq s' k ‚ü©
  | step_stm_seq_value
      (œÉ : Ty) (v : Val œÉ) (k : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_seq (stm_val œÉ v) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , k ‚ü©
  | step_stm_seq_fail
      (œÉ : Ty) (s : string) (k : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_seq (stm_fail œÉ s) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©

  | step_stm_call
      {Œî} {f : ùë≠ Œî œÑ} (es : NamedEnv (Exp Œì) Œî) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_call f es ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_call_frame (evals es Œ¥) (FunDef f) ‚ü©
  | step_stm_call_frame_step
      (Œî : PCtx) {Œ¥Œî Œ¥Œî' : CStore Œî} (s s' : Stm Œî œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) :
      ‚ü® Œ≥ , Œº , Œ¥Œî , s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥Œî' , s' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_call_frame Œ¥Œî s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥ , stm_call_frame Œ¥Œî' s' ‚ü©
  | step_stm_call_frame_value
      (Œî : PCtx) {Œ¥Œî : CStore Œî} (v : Val œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_call_frame Œ¥Œî (stm_val œÑ v) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_val œÑ v ‚ü©
  | step_stm_call_frame_fail
      (Œî : PCtx) {Œ¥Œî : CStore Œî} (s : string) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_call_frame Œ¥Œî (stm_fail œÑ s) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©
  | step_stm_foreign
      {Œî} {f : ùë≠ùëø Œî œÑ} (es : NamedEnv (Exp Œì) Œî) (res : string + Val œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) :
      ForeignCall f (evals es Œ¥) res Œ≥ Œ≥' Œº Œº' ->
      ‚ü® Œ≥  , Œº  , Œ¥ , stm_foreign f es ‚ü© --->
      ‚ü® Œ≥' , Œº' , Œ¥ , match res with
                      | inl msg => stm_fail œÑ msg
                      | inr v__œÉ  => stm_val œÑ v__œÉ
                      end ‚ü©
  | step_stm_lemmak
      {Œî} {l : ùë≥ Œî} (es : NamedEnv (Exp Œì) Œî) (k : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_lemmak l es k ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , k ‚ü©

  | step_stm_assign_value
      (x : PVar) {xInŒì : x‚à∑œÑ ‚àà Œì} (v : Val œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_assign x (stm_val œÑ v) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ ‚ü™ x ‚Ü¶ v ‚ü´ , stm_val œÑ v ‚ü©
  | step_stm_assign_fail
      (x : PVar) {xInŒì : x‚à∑œÑ ‚àà Œì} (s : string) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_assign x (stm_fail œÑ s) ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©
  | step_stm_assign_step
      (x : PVar) {xInŒì : x‚à∑œÑ ‚àà Œì} (s s' : Stm Œì œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) (Œ¥' : CStore Œì) :
      ‚ü® Œ≥ , Œº , Œ¥ , s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , s' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_assign x s ‚ü© ---> ‚ü® Œ≥' , Œº' , Œ¥' , stm_assign x s' ‚ü©

  | step_stm_if
      (e : Exp Œì ty.bool) (s1 s2 : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_if e s1 s2 ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , if eval e Œ¥ then s1 else s2 ‚ü©
  | step_stm_assertk
      (e1 : Exp Œì ty.bool) (e2 : Exp Œì ty.string) (k : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_assertk e1 e2 k ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , if eval e1 Œ¥ then k else stm_fail œÑ (eval e2 Œ¥) ‚ü©

  | step_stm_match_list
      {œÉ : Ty} (e : Exp Œì (ty.list œÉ)) (alt_nil : Stm Œì œÑ)
      (xh xt : PVar) (alt_cons : Stm (Œì ‚ñª xh‚à∑œÉ ‚ñª xt‚à∑ty.list œÉ) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_list e alt_nil xh xt alt_cons ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , match eval e Œ¥ with
                | nil => alt_nil
                | cons vh vt => stm_block (env.snoc (env.snoc env.nil (xh‚à∑œÉ) vh) (xt‚à∑ty.list œÉ) vt) alt_cons
                end
      ‚ü©
  | step_stm_match_sum
      {œÉinl œÉinr : Ty} (e : Exp Œì (ty.sum œÉinl œÉinr))
      (xinl : PVar) (alt_inl : Stm (Œì ‚ñª xinl‚à∑œÉinl) œÑ)
      (xinr : PVar) (alt_inr : Stm (Œì ‚ñª xinr‚à∑œÉinr) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_sum e xinl alt_inl xinr alt_inr ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , match eval e Œ¥ with
                | inl v => stm_block (env.snoc env.nil (xinl‚à∑œÉinl) v) alt_inl
                | inr v => stm_block (env.snoc env.nil (xinr‚à∑œÉinr) v) alt_inr
                end
      ‚ü©
  | step_stm_match_prod
      {œÉ1 œÉ2 : Ty} (e : Exp Œì (ty.prod œÉ1 œÉ2)) (xl xr : PVar)
      (rhs : Stm (Œì ‚ñª xl‚à∑œÉ1 ‚ñª xr‚à∑œÉ2) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_prod e xl xr rhs ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , let (vl , vr) := eval e Œ¥ in
                stm_block (env.snoc (env.snoc env.nil (xl‚à∑œÉ1) vl) (xr‚à∑œÉ2) vr) rhs
      ‚ü©
  | step_stm_match_enum
      {E : enumi} (e : Exp Œì (ty.enum E))
      (alts : forall (K : enumt E), Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_enum E e alts ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , alts (eval e Œ¥) ‚ü©
  | step_stm_match_tuple
      {Œî œÉs} (e : Exp Œì (ty.tuple œÉs)) (p : TuplePat œÉs Œî) (rhs : Stm (Œì ‚ñª‚ñª Œî) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_tuple e p rhs ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_block (tuple_pattern_match_val p (eval e Œ¥)) rhs ‚ü©

  | step_stm_match_union
      {U : unioni} (e : Exp Œì (ty.union U))
      (alt__ctx : forall (K : unionk U), PCtx)
      (alt__pat : forall (K : unionk U), Pattern (alt__ctx K) (unionk_ty U K))
      (alt__rhs : forall (K : unionk U), Stm (Œì ‚ñª‚ñª alt__ctx K) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_union U e alt__pat alt__rhs ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , let (K , v) := unionv_unfold U (eval e Œ¥) in
                stm_block (pattern_match_val (alt__pat K) v) (alt__rhs K)
      ‚ü©
  | step_stm_match_record
      {R : recordi} {Œî : PCtx} (e : Exp Œì (ty.record R))
      (p : RecordPat (recordf_ty R) Œî) (rhs : Stm (Œì ‚ñª‚ñª Œî) œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_record R e p rhs ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_block (record_pattern_match_val p (eval e Œ¥)) rhs ‚ü©

  | step_stm_match_bvec
      {n : nat} (e : Exp Œì (ty.bvec n)) (rhs : bv n -> Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_match_bvec n e rhs ‚ü© --->
      ‚ü® Œ≥ , Œº , Œ¥ , rhs (eval e Œ¥) ‚ü©

  | step_stm_read_register
      (r : ùëπùë¨ùëÆ œÑ) :
      ‚ü® Œ≥, Œº , Œ¥, stm_read_register r ‚ü© ---> ‚ü® Œ≥, Œº , Œ¥, stm_val œÑ (read_register Œ≥ r) ‚ü©
  | step_stm_write_register
      (r : ùëπùë¨ùëÆ œÑ) (e : Exp Œì œÑ) :
      let v := eval e Œ¥ in
      ‚ü® Œ≥ , Œº , Œ¥, stm_write_register r e ‚ü© ---> ‚ü® write_register Œ≥ r v , Œº , Œ¥ , stm_val œÑ v ‚ü©

  | step_stm_bind_step
      (œÉ : Ty) (s s' : Stm Œì œÉ) (k : Val œÉ -> Stm Œì œÑ)
      (Œ≥' : RegStore) (Œº' : Memory) (Œ¥' : CStore Œì) :
      ‚ü® Œ≥ , Œº , Œ¥ , s ‚ü© ---> ‚ü® Œ≥', Œº' , Œ¥' , s' ‚ü© ->
      ‚ü® Œ≥ , Œº , Œ¥ , stm_bind s k ‚ü© ---> ‚ü® Œ≥', Œº' , Œ¥' , stm_bind s' k ‚ü©
  | step_stm_bind_value
      (œÉ : Ty) (v : Val œÉ) (k : Val œÉ -> Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_bind (stm_val œÉ v) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , k v ‚ü©
  | step_stm_bind_fail
      (œÉ : Ty) (s : string) (k : Val œÉ -> Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_bind (stm_fail œÉ s) k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , stm_fail œÑ s ‚ü©

  | step_debugk
      (k : Stm Œì œÑ) :
      ‚ü® Œ≥ , Œº , Œ¥ , stm_debugk k ‚ü© ---> ‚ü® Œ≥ , Œº , Œ¥ , k ‚ü©

  where "‚ü® Œ≥1 , Œº1 , Œ¥1 , s1 ‚ü© ---> ‚ü® Œ≥2 , Œº2 , Œ¥2 , s2 ‚ü©" := (@Step _ _ Œ≥1%env Œº1%env Œ¥1%env Œ≥2%env Œº2%env Œ¥2%env s1%exp s2%exp).

  Inductive Steps {Œì : PCtx} {œÉ : Ty} (Œ≥1 : RegStore) (Œº1 : Memory) (Œ¥1 : CStore Œì) (s1 : Stm Œì œÉ) : RegStore -> Memory -> CStore Œì -> Stm Œì œÉ -> Prop :=
  | step_refl : Steps Œ≥1 Œº1 Œ¥1 s1 Œ≥1 Œº1 Œ¥1 s1
  | step_trans {Œ≥2 Œ≥3 : RegStore} {Œº2 Œº3 : Memory} {Œ¥2 Œ¥3 : CStore Œì} {s2 s3 : Stm Œì œÉ} :
      Step Œ≥1 Œº1 Œ¥1 Œ≥2 Œº2 Œ¥2 s1 s2 -> Steps Œ≥2 Œº2 Œ¥2 s2 Œ≥3 Œº3 Œ¥3 s3 -> Steps Œ≥1 Œº1 Œ¥1 s1 Œ≥3 Œº3 Œ¥3 s3.

  Module Import SmallStepNotations.
    Notation "‚ü® Œ≥1 , Œº1 , Œ¥1 , s1 ‚ü© ---> ‚ü® Œ≥2 , Œº2 , Œ¥2 , s2 ‚ü©" := (@Step _ _ Œ≥1%env Œº1%env Œ¥1%env Œ≥2%env Œº2%env Œ¥2%env s1%exp s2%exp).
    Notation "‚ü® Œ≥1 , Œº1 , Œ¥1 , s1 ‚ü© --->* ‚ü® Œ≥2 , Œº2 , Œ¥2 , s2 ‚ü©" := (@Steps _ _ Œ≥1 Œº1 Œ¥1 s1 Œ≥2 Œº2 Œ¥2 s2).
  End SmallStepNotations.

  (* Tests if a statement is a final one, i.e. a finished computation. *)
  Ltac microsail_stm_is_final s :=
    lazymatch s with
    | stm_val _ _  => idtac
    | stm_fail _ _ => idtac
    end.

  (* Tests if a statement has a primitive step, i.e. it can be reduced
     by an axiom rule of the step relation instead of a congruence rule. *)
  Ltac microsail_stm_primitive_step s :=
    first
      [ lazymatch s with
        | stm_call_frame _ ?s' => microsail_stm_is_final s'
        | stm_let _ _ ?s' _    => microsail_stm_is_final s'
        | stm_block _ ?s'      => microsail_stm_is_final s'
        | stm_seq ?s' _        => microsail_stm_is_final s'
        | stm_assign _ ?s'     => microsail_stm_is_final s'
        | stm_bind ?s' _       => microsail_stm_is_final s'
        end
      | lazymatch head s with
        | @stm_call           => idtac
        | @stm_foreign        => idtac
        | @stm_lemmak         => idtac
        | @stm_assertk        => idtac
        | @stm_fail           => idtac
        | @stm_exp            => idtac
        | @stm_if             => idtac
        | @stm_val            => idtac
        | @stm_match_sum      => idtac
        | @stm_match_list     => idtac
        | @stm_match_prod     => idtac
        | @stm_match_enum     => idtac
        | @stm_match_tuple    => idtac
        | @stm_match_union    => idtac
        | @stm_match_record   => idtac
        | @stm_match_bvec     => idtac
        | @stm_read_register  => idtac
        | @stm_write_register => idtac
        | @stm_debugk         => idtac
        end
      ].

  (* This 'Lemma' simply exists for testing that the above predicate on
     statements is complete with respect to the step relation. *)
  Lemma microsail_stm_primitive_step__complete {Œì œÉ Œ≥1 Œ≥2 Œº1 Œº2 Œ¥1 Œ¥2} {s1 s2 : Stm Œì œÉ} :
    ‚ü® Œ≥1 , Œº1 , Œ¥1 , s1 ‚ü© ---> ‚ü® Œ≥2 , Œº2 , Œ¥2 , s2 ‚ü© -> True.
    intro step. remember s1 as s1'.
    dependent elimination step;
      match goal with
      | [ H: ‚ü® _,_,_,_ ‚ü© ---> ‚ü® _,_,_,_ ‚ü© |- _ ] =>
        (* If there is a step hypothesis then this case represents a congruence
           rule, not an axiom rule. *)
        constructor
      | [ H: ?s1' = s1 |- _ ] =>
        (* Otherwise, it's an axiom rule and the microsail_stm_primitive_step
           tactic should recognize it. *)
        microsail_stm_primitive_step s1'; constructor
      end; fail.
    Abort.

  Definition Final {Œì œÉ} (s : Stm Œì œÉ) : Prop :=
    match s with
    | stm_val _ _   => True
    | stm_fail _ _ => True
    | _ => False
    end.

  Definition ResultOrFail {Œì œÉ} (s : Stm Œì œÉ) :
    forall (POST : Val œÉ -> Prop), Prop :=
    match s with
    | stm_val _ v => fun POST => POST v
    | stm_fail _ _ => fun _ => True
    | _ => fun _ => False
    end.

  Lemma result_or_fail_inversion {Œì œÉ} (s : Stm Œì œÉ) (POST : Val œÉ -> Prop) :
    ResultOrFail s POST -> (exists msg, s = stm_fail _ msg)
                        \/ (exists v, s = stm_val _ v /\ POST v).
  Proof. destruct s; cbn in *; try contradiction; eauto. Qed.

  (* This predicate encodes that the statement s is a finished computation and
     that the result is not a failure. This is a computational version that is
     better suited for the goal and the inversion below is better suited for
     a hypothesis. *)
  Definition ResultNoFail {Œì œÉ} (s : Stm Œì œÉ) :
    forall (POST : Val œÉ -> Prop), Prop :=
    match s with
    | stm_val _ v => fun POST => POST v
    | _ => fun _ => False
    end.

  Lemma result_no_fail_inversion {Œì œÉ} (s : Stm Œì œÉ) (POST : Val œÉ -> Prop) :
    ResultNoFail s POST -> exists v, s = stm_val _ v /\ POST v.
  Proof. destruct s; cbn in *; try contradiction; eauto. Qed.

End SmallStepOn.
